"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sugar-high@0.6.0";
exports.ids = ["vendor-chunks/sugar-high@0.6.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/sugar-high@0.6.0/node_modules/sugar-high/lib/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/sugar-high@0.6.0/node_modules/sugar-high/lib/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SugarHigh: () => (/* binding */ SugarHigh),\n/* harmony export */   highlight: () => (/* binding */ highlight),\n/* harmony export */   tokenize: () => (/* binding */ tokenize)\n/* harmony export */ });\n// @ts-check\n\nconst jsxBrackets = new Set(['<', '>', '{', '}', '[', ']'])\nconst keywords = new Set([\n  'for',\n  'do',\n  'while',\n  'if',\n  'else',\n  'return',\n  'function',\n  'var',\n  'let',\n  'const',\n  'true',\n  'false',\n  'undefined',\n  'this',\n  'new',\n  'delete',\n  'typeof',\n  'in',\n  'instanceof',\n  'void',\n  'break',\n  'continue',\n  'switch',\n  'case',\n  'default',\n  'throw',\n  'try',\n  'catch',\n  'finally',\n  'debugger',\n  'with',\n  'yield',\n  'async',\n  'await',\n  'class',\n  'extends',\n  'super',\n  'import',\n  'export',\n  'from',\n  'static',\n])\n\nconst signs = new Set([\n  '+',\n  '-',\n  '*',\n  '/',\n  '%',\n  '=',\n  '!',\n  '&',\n  '|',\n  '^',\n  '~',\n  '!',\n  '?',\n  ':',\n  '.',\n  ',',\n  ';',\n  `'`,\n  '\"',\n  '.',\n  '(',\n  ')',\n  '[',\n  ']',\n  '#',\n  '@',\n  '\\\\',\n  ...jsxBrackets,\n])\n\n\n/**\n *\n * 0  - identifier\n * 1  - keyword\n * 2  - string\n * 3  - Class, number and null\n * 4  - property\n * 5  - entity\n * 6  - jsx literals\n * 7  - sign\n * 8  - comment\n * 9  - break\n * 10 - space\n *\n */\nconst types = /** @type {const} */ ([\n  'identifier',\n  'keyword',\n  'string',\n  'class',\n  'property',\n  'entity',\n  'jsxliterals',\n  'sign',\n  'comment',\n  'break',\n  'space',\n])\nconst [\n  T_IDENTIFIER,\n  T_KEYWORD,\n  T_STRING,\n  T_CLS_NUMBER,\n  T_PROPERTY,\n  T_ENTITY,\n  T_JSX_LITERALS,\n  T_SIGN,\n  T_COMMENT,\n  T_BREAK,\n  T_SPACE,\n] = /** @types {const} */ types.map((_, i) => i)\n\nfunction isSpaces(str) {\n  return /^[^\\S\\r\\n]+$/g.test(str)\n}\n\nfunction isSign(ch) {\n  return signs.has(ch)\n}\n\nfunction encode(str) {\n  return str\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#039;')\n}\n\nfunction isWord(chr) {\n  return /^[\\w_]+$/.test(chr) || hasUnicode(chr)\n}\n\nfunction isCls(str) {\n  const chr0 = str[0]\n  return isWord(chr0) &&\n    chr0 === chr0.toUpperCase() ||\n    str === 'null'\n}\n\nfunction hasUnicode(s) {\n  return /[^\\u0000-\\u007f]/.test(s);\n}\n\nfunction isAlpha(chr) {\n  return /^[a-zA-Z]$/.test(chr)\n}\n\nfunction isIdentifierChar(chr) {\n  return isAlpha(chr) || hasUnicode(chr)\n}\n\nfunction isIdentifier(str) {\n  return isIdentifierChar(str[0]) && (str.length === 1 || isWord(str.slice(1)))\n}\n\nfunction isStrTemplateChr(chr) {\n  return chr === '`'\n}\n\nfunction isSingleQuotes(chr) {\n  return chr === '\"' || chr === \"'\"\n}\n\nfunction isStringQuotation(chr) {\n  return isSingleQuotes(chr) || isStrTemplateChr(chr)\n}\n\nfunction isCommentStart(str) {\n  str = str.slice(0, 2)\n  return str === '//' || str === '/*'\n}\n\nfunction isRegexStart(str) {\n  return str[0] === '/' && !isCommentStart(str[0] + str[1])\n}\n\n/**\n * @param {string} code\n * @return {Array<[number, string]>}\n */\nfunction tokenize(code) {\n  let current = ''\n  let type = -1\n  /** @type {[number, string]} */\n  let last = [-1, '']\n  /** @type {[number, string]} */\n  let beforeLast = [-2, '']\n  /** @type {Array<[number, string]>} */\n  const tokens = []\n\n  /** @type boolean if entered jsx tag, inside <open tag> or </close tag> */\n  let __jsxEnter = false\n  /**\n   * @type {0 | 1 | 2}\n   * @example\n   * 0 for not in jsx;\n   * 1 for open jsx tag;\n   * 2 for closing jsx tag;\n   **/\n  let __jsxTag = 0\n  let __jsxExpr = false\n\n  // only match paired (open + close) tags, not self-closing tags\n  let __jsxStack = 0\n  const __jsxChild = () => __jsxEnter && !__jsxExpr && !__jsxTag\n  // < __content__ >\n  const inJsxTag = () => __jsxTag && !__jsxChild()\n  // {'__content__'}\n  const inJsxLiterals = () => !__jsxTag && __jsxChild() && !__jsxExpr && __jsxStack > 0\n\n  /** @type {string | null} */\n  let __strQuote = null\n  let __strTemplateExprStack = 0\n  let __strTemplateQuoteStack = 0\n  const inStringQuotes = () => __strQuote !== null\n  const inStrTemplateLiterals = () => (__strTemplateQuoteStack > __strTemplateExprStack)\n  const inStrTemplateExpr = () => __strTemplateQuoteStack > 0 && (__strTemplateQuoteStack === __strTemplateExprStack)\n  const inStringContent = () => inStringQuotes() || inStrTemplateLiterals()\n\n  /**\n   *\n   * @param {string} token\n   * @returns {number}\n   */\n  function classify(token) {\n    const isLineBreak = token === '\\n'\n    // First checking if they're attributes values\n    if (inJsxTag()) {\n      if (inStringQuotes()) {\n        return T_STRING\n      }\n\n      const [, lastToken] = last\n      if (isIdentifier(token)) {\n        // classify jsx open tag\n        if ((lastToken === '<' || lastToken === '</')) \n          return T_ENTITY\n      }\n    }\n    // Then determine if they're jsx literals\n    const isJsxLiterals = inJsxLiterals()\n    if (isJsxLiterals) return T_JSX_LITERALS\n\n    // Determine strings first before other types\n    if (inStringQuotes()) {\n      return T_STRING\n    } else if (keywords.has(token)) {\n      return last[1] === '.' ? T_IDENTIFIER : T_KEYWORD\n    } else if (isLineBreak) {\n      return T_BREAK\n    } else if (isSpaces(token)) {\n      return T_SPACE\n    } else if (token.split('').every(isSign)) {\n      return T_SIGN\n    } else if (isCls(token)) {\n      return inJsxTag() ? T_IDENTIFIER : T_CLS_NUMBER\n    } else {\n      if (isIdentifier(token)) {\n        const isLastPropDot = last[1] === '.' && isIdentifier(beforeLast[1])\n\n        if (!inStringContent() && !isLastPropDot) return T_IDENTIFIER\n        if (isLastPropDot) return T_PROPERTY\n      }\n      return T_STRING\n    }\n  }\n\n  const append = (_type, _token) => {\n    if (_token) {\n      current = _token\n    }\n    if (current) {\n      type = _type || classify(current)\n      /** @type [number, string]  */\n      const pair = [type, current]\n      if (type !== T_SPACE && type !== T_BREAK) {\n        beforeLast = last\n        last = pair\n      }\n      tokens.push(pair)\n    }\n    current = ''\n  }\n  for (let i = 0; i < code.length; i++) {\n    const curr = code[i]\n    const prev = code[i - 1]\n    const next = code[i + 1]\n    const p_c = prev + curr // previous and current\n    const c_n = curr + next // current and next\n\n    // Determine string quotation outside of jsx literals.\n    // Inside jsx literals, string quotation is still part of it.\n    if (isSingleQuotes(curr) && !inJsxLiterals()) {\n      append()\n      if (prev !== `\\\\`) {\n        if (__strQuote && curr === __strQuote) {\n          __strQuote = null\n        } else if (!__strQuote) {\n          __strQuote = curr\n        }\n      }\n\n      append(T_STRING, curr)\n      continue\n    }\n\n    if (!inStrTemplateLiterals()) {\n      if (prev !== '\\\\n' && isStrTemplateChr(curr)) {\n        append()\n        append(T_STRING, curr)\n        __strTemplateQuoteStack++\n        continue\n      }\n    }\n\n    if (inStrTemplateLiterals()) {\n      if (prev !== '\\\\n' && isStrTemplateChr(curr)) {\n        if (__strTemplateQuoteStack > 0) {\n          append()\n          __strTemplateQuoteStack--\n          append(T_STRING, curr)\n          continue\n        }\n      }\n\n      if (c_n === '${') {\n        __strTemplateExprStack++\n        append(T_STRING)\n        append(T_SIGN, c_n)\n        i++\n        continue\n      }\n    }\n\n    if (inStrTemplateExpr() && curr === '}') {\n      append()\n      __strTemplateExprStack--\n      append(T_SIGN, curr)\n      continue\n    }\n\n    if (__jsxChild()) {\n      if (curr === '{') {\n        append()\n        append(T_SIGN, curr)\n        __jsxExpr = true\n        continue\n      }\n    }\n\n    if (__jsxEnter) {\n      // <: open tag sign\n      // new '<' not inside jsx\n      if (!__jsxTag && curr === '<') {\n        append()\n        if (next === '/') {\n          // close tag\n          __jsxTag = 2\n          current = c_n\n          i++\n        } else {\n          // open tag\n          __jsxTag = 1\n          current = curr\n        }\n        append(T_SIGN)\n        continue\n      }\n      if (__jsxTag) {\n        // >: open tag close sign or closing tag closing sign\n        // and it's not `=>` or `/>`\n        // `curr` could be `>` or `/`\n        if ((curr === '>' && !'/='.includes(prev))) {\n          append()\n          if (__jsxTag === 1) {\n            __jsxTag = 0\n            __jsxStack++\n          } else {\n            __jsxTag = 0\n            __jsxEnter = false\n          }\n          append(T_SIGN, curr)\n          continue\n        }\n\n        // >: tag self close sign or close tag sign\n        if (c_n === '/>' || c_n === '</') {\n          // if current token is not part of close tag sign, push it first\n          if (current !== '<' && current !== '/') {\n            append()\n          }\n\n          if (c_n === '/>') {\n            __jsxTag = 0\n          } else {\n            // is '</'\n            __jsxStack--\n          }\n\n          if (!__jsxStack)\n            __jsxEnter = false\n\n          current = c_n\n          i++\n          append(T_SIGN)\n          continue\n        }\n\n        // <: open tag sign\n        if (curr === '<') {\n          append()\n          current = curr\n          append(T_SIGN)\n          continue\n        }\n\n        // jsx property\n        // `-` in data-prop\n        if (next === '-'  && !inStringContent() && !inJsxLiterals()) {\n          if (current) {\n            append(T_PROPERTY, current + curr + next)\n            i += 1\n            continue\n          }\n        }\n        // `=` in property=<value>\n        if (next === '=') {\n          const prop = current ? (current + curr) : curr\n          if (isIdentifier(prop)) {\n            current = prop\n            append(T_PROPERTY)\n          }\n          continue\n        }\n      }\n    }\n\n    // if it's not in a jsx tag declaration or a string, close child if next is jsx close tag\n    if (!__jsxTag && (curr === '<' && isIdentifierChar(next) || c_n === '</')) {\n      __jsxTag = next === '/' ? 2 : 1\n\n      // current and next char can form a jsx open or close tag\n      if (curr === '<' && (next === '/' || isAlpha(next))) {\n        __jsxEnter = true\n      }\n    }\n\n    const isQuotationChar = isStringQuotation(curr)\n    const isStringTemplateLiterals = inStrTemplateLiterals()\n    const isRegexChar = !__jsxEnter && isRegexStart(c_n)\n    const isJsxLiterals = inJsxLiterals()\n\n    // string quotation\n    if (isQuotationChar || isStringTemplateLiterals || isSingleQuotes(__strQuote)) {\n      current += curr\n    } else if (isRegexChar) {\n      append()\n      const [lastType, lastToken] = last\n      // Special cases that are not considered as regex:\n      // * (expr1) / expr2: `)` before `/` operator is still in expression\n      // * <non comment start>/ expr: non comment start before `/` is not regex\n      if (\n        isRegexChar &&\n        lastType !== -1 &&\n        !(\n          (lastType === T_SIGN && ')' !== lastToken) ||\n          lastType === T_COMMENT\n        )\n      ) {\n        current = curr\n        append()\n        continue\n      }\n\n      const start = i++\n\n      // end of line of end of file\n      const isEof = () => i >= code.length\n      const isEol = () => isEof() || code[i] === '\\n'\n\n      let foundClose = false\n      // regex\n      for (; !isEol(); i++) {\n        if (code[i] === '/' && code[i - 1] !== '\\\\') {\n          foundClose = true\n          // append regex flags\n          while (start !== i && /^[a-z]$/.test(code[i + 1]) && !isEol()) {\n            i++\n          }\n          break\n        }\n      }\n      if (start !== i && foundClose) {\n        // If current line is fully closed with string quotes or regex slashes,\n        // add them to tokens\n        current = code.slice(start, i + 1)\n        append(T_STRING)\n      } else {\n        // If it doesn't match any of the above, just leave it as operator and move on\n        current = curr\n        append()\n        i = start\n      }\n    } else if (isCommentStart(c_n)) {\n      append()\n      const start = i\n      if (next === '/') {\n        for (; i < code.length && code[i] !== '\\n'; i++);\n      } else {\n        for (; i < code.length && code[i - 1] + code[i] !== '*/'; i++);\n      }\n      current = code.slice(start, i + 1)\n      append(T_COMMENT)\n    } else if (curr === ' ' || curr === '\\n') {\n      if (\n        curr === ' ' &&\n        (\n          (isSpaces(current) || !current) ||\n          isJsxLiterals\n        )\n      ) {\n        current += curr\n        if (next === '<') {\n          append()\n        }\n      } else {\n        append()\n        current = curr\n        append()\n      }\n    } else {\n      if (__jsxExpr && curr === '}') {\n        append()\n        current = curr\n        append()\n        __jsxExpr = false\n      } else if (\n        // it's jsx literals and is not a jsx bracket\n        (isJsxLiterals && !jsxBrackets.has(curr)) ||\n        // same type char as previous one in current token\n        ((isWord(curr) === isWord(current[current.length - 1]) || __jsxChild()) && !signs.has(curr))\n      ) {\n        current += curr\n      } else {\n        if (p_c === '</') {\n          current = p_c\n        }\n        append()\n\n        if (p_c !== '</') {\n          current = curr\n\n        }\n        if ((c_n === '</' || c_n === '/>')) {\n          current = c_n\n          append()\n          i++\n        }\n        else if (jsxBrackets.has(curr)) append()\n      }\n    }\n  }\n\n  append()\n\n  return tokens\n}\n\n/**\n * @param {Array<[number, string]>} tokens\n * @return {Array<string>}\n */\nfunction generate(tokens) {\n  const linesHtml = []\n  const createLine = (content) => `<span class=\"sh__line\">${content}</span>`\n\n  function flushLine(tokens) {\n    linesHtml.push(createLine(\n      tokens.map(([type, value]) => (\n        `<span class=\"sh__token--${types[type]}\" style=\"color: var(--sh-${types[type]})\">${encode(value)}</span>`\n      ))\n      .join('')\n    ))\n  }\n  const lineTokens = []\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i]\n    const [type, value] = token\n    if (type !== T_BREAK) {\n      // Divide multi-line token into multi-line code\n      if (value.includes('\\n')) {\n        const lines = value.split('\\n')\n        for (let j = 0; j < lines.length; j++) {\n          lineTokens.push([type, lines[j]])\n          if (j < lines.length - 1) {\n            flushLine(lineTokens)\n            lineTokens.length = 0\n          }\n        }\n      } else {\n        lineTokens.push(token)\n      }\n    } else {\n      lineTokens.push([type, ''])\n      flushLine(lineTokens)\n      lineTokens.length = 0\n    }\n  }\n\n  if (lineTokens.length)\n    flushLine(lineTokens)\n\n  return linesHtml\n}\n\n/**\n *\n * @param {string} code\n * @returns {string}\n */\nfunction highlight(code) {\n  const tokens = tokenize(code)\n  const output = generate(tokens).join('\\n')\n  return output\n}\n\n// namespace\nconst SugarHigh = /** @type {const} */ {\n  TokenTypes: types,\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vc3VnYXItaGlnaEAwLjYuMC9ub2RlX21vZHVsZXMvc3VnYXItaGlnaC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7O0FBRUEseUNBQXlDLEtBQUs7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUEsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFDQUFxQztBQUNwRCxRQUFRO0FBQ1IsZUFBZSxtREFBbUQ7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFFBQVE7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZLDJCQUEyQixZQUFZLEtBQUssY0FBYztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnBucG0vc3VnYXItaGlnaEAwLjYuMC9ub2RlX21vZHVsZXMvc3VnYXItaGlnaC9saWIvaW5kZXguanM/YzlkMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAdHMtY2hlY2tcblxuY29uc3QganN4QnJhY2tldHMgPSBuZXcgU2V0KFsnPCcsICc+JywgJ3snLCAnfScsICdbJywgJ10nXSlcbmNvbnN0IGtleXdvcmRzID0gbmV3IFNldChbXG4gICdmb3InLFxuICAnZG8nLFxuICAnd2hpbGUnLFxuICAnaWYnLFxuICAnZWxzZScsXG4gICdyZXR1cm4nLFxuICAnZnVuY3Rpb24nLFxuICAndmFyJyxcbiAgJ2xldCcsXG4gICdjb25zdCcsXG4gICd0cnVlJyxcbiAgJ2ZhbHNlJyxcbiAgJ3VuZGVmaW5lZCcsXG4gICd0aGlzJyxcbiAgJ25ldycsXG4gICdkZWxldGUnLFxuICAndHlwZW9mJyxcbiAgJ2luJyxcbiAgJ2luc3RhbmNlb2YnLFxuICAndm9pZCcsXG4gICdicmVhaycsXG4gICdjb250aW51ZScsXG4gICdzd2l0Y2gnLFxuICAnY2FzZScsXG4gICdkZWZhdWx0JyxcbiAgJ3Rocm93JyxcbiAgJ3RyeScsXG4gICdjYXRjaCcsXG4gICdmaW5hbGx5JyxcbiAgJ2RlYnVnZ2VyJyxcbiAgJ3dpdGgnLFxuICAneWllbGQnLFxuICAnYXN5bmMnLFxuICAnYXdhaXQnLFxuICAnY2xhc3MnLFxuICAnZXh0ZW5kcycsXG4gICdzdXBlcicsXG4gICdpbXBvcnQnLFxuICAnZXhwb3J0JyxcbiAgJ2Zyb20nLFxuICAnc3RhdGljJyxcbl0pXG5cbmNvbnN0IHNpZ25zID0gbmV3IFNldChbXG4gICcrJyxcbiAgJy0nLFxuICAnKicsXG4gICcvJyxcbiAgJyUnLFxuICAnPScsXG4gICchJyxcbiAgJyYnLFxuICAnfCcsXG4gICdeJyxcbiAgJ34nLFxuICAnIScsXG4gICc/JyxcbiAgJzonLFxuICAnLicsXG4gICcsJyxcbiAgJzsnLFxuICBgJ2AsXG4gICdcIicsXG4gICcuJyxcbiAgJygnLFxuICAnKScsXG4gICdbJyxcbiAgJ10nLFxuICAnIycsXG4gICdAJyxcbiAgJ1xcXFwnLFxuICAuLi5qc3hCcmFja2V0cyxcbl0pXG5cblxuLyoqXG4gKlxuICogMCAgLSBpZGVudGlmaWVyXG4gKiAxICAtIGtleXdvcmRcbiAqIDIgIC0gc3RyaW5nXG4gKiAzICAtIENsYXNzLCBudW1iZXIgYW5kIG51bGxcbiAqIDQgIC0gcHJvcGVydHlcbiAqIDUgIC0gZW50aXR5XG4gKiA2ICAtIGpzeCBsaXRlcmFsc1xuICogNyAgLSBzaWduXG4gKiA4ICAtIGNvbW1lbnRcbiAqIDkgIC0gYnJlYWtcbiAqIDEwIC0gc3BhY2VcbiAqXG4gKi9cbmNvbnN0IHR5cGVzID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFtcbiAgJ2lkZW50aWZpZXInLFxuICAna2V5d29yZCcsXG4gICdzdHJpbmcnLFxuICAnY2xhc3MnLFxuICAncHJvcGVydHknLFxuICAnZW50aXR5JyxcbiAgJ2pzeGxpdGVyYWxzJyxcbiAgJ3NpZ24nLFxuICAnY29tbWVudCcsXG4gICdicmVhaycsXG4gICdzcGFjZScsXG5dKVxuY29uc3QgW1xuICBUX0lERU5USUZJRVIsXG4gIFRfS0VZV09SRCxcbiAgVF9TVFJJTkcsXG4gIFRfQ0xTX05VTUJFUixcbiAgVF9QUk9QRVJUWSxcbiAgVF9FTlRJVFksXG4gIFRfSlNYX0xJVEVSQUxTLFxuICBUX1NJR04sXG4gIFRfQ09NTUVOVCxcbiAgVF9CUkVBSyxcbiAgVF9TUEFDRSxcbl0gPSAvKiogQHR5cGVzIHtjb25zdH0gKi8gdHlwZXMubWFwKChfLCBpKSA9PiBpKVxuXG5mdW5jdGlvbiBpc1NwYWNlcyhzdHIpIHtcbiAgcmV0dXJuIC9eW15cXFNcXHJcXG5dKyQvZy50ZXN0KHN0cilcbn1cblxuZnVuY3Rpb24gaXNTaWduKGNoKSB7XG4gIHJldHVybiBzaWducy5oYXMoY2gpXG59XG5cbmZ1bmN0aW9uIGVuY29kZShzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgLnJlcGxhY2UoLycvZywgJyYjMDM5OycpXG59XG5cbmZ1bmN0aW9uIGlzV29yZChjaHIpIHtcbiAgcmV0dXJuIC9eW1xcd19dKyQvLnRlc3QoY2hyKSB8fCBoYXNVbmljb2RlKGNocilcbn1cblxuZnVuY3Rpb24gaXNDbHMoc3RyKSB7XG4gIGNvbnN0IGNocjAgPSBzdHJbMF1cbiAgcmV0dXJuIGlzV29yZChjaHIwKSAmJlxuICAgIGNocjAgPT09IGNocjAudG9VcHBlckNhc2UoKSB8fFxuICAgIHN0ciA9PT0gJ251bGwnXG59XG5cbmZ1bmN0aW9uIGhhc1VuaWNvZGUocykge1xuICByZXR1cm4gL1teXFx1MDAwMC1cXHUwMDdmXS8udGVzdChzKTtcbn1cblxuZnVuY3Rpb24gaXNBbHBoYShjaHIpIHtcbiAgcmV0dXJuIC9eW2EtekEtWl0kLy50ZXN0KGNocilcbn1cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyQ2hhcihjaHIpIHtcbiAgcmV0dXJuIGlzQWxwaGEoY2hyKSB8fCBoYXNVbmljb2RlKGNocilcbn1cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyKHN0cikge1xuICByZXR1cm4gaXNJZGVudGlmaWVyQ2hhcihzdHJbMF0pICYmIChzdHIubGVuZ3RoID09PSAxIHx8IGlzV29yZChzdHIuc2xpY2UoMSkpKVxufVxuXG5mdW5jdGlvbiBpc1N0clRlbXBsYXRlQ2hyKGNocikge1xuICByZXR1cm4gY2hyID09PSAnYCdcbn1cblxuZnVuY3Rpb24gaXNTaW5nbGVRdW90ZXMoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09ICdcIicgfHwgY2hyID09PSBcIidcIlxufVxuXG5mdW5jdGlvbiBpc1N0cmluZ1F1b3RhdGlvbihjaHIpIHtcbiAgcmV0dXJuIGlzU2luZ2xlUXVvdGVzKGNocikgfHwgaXNTdHJUZW1wbGF0ZUNocihjaHIpXG59XG5cbmZ1bmN0aW9uIGlzQ29tbWVudFN0YXJ0KHN0cikge1xuICBzdHIgPSBzdHIuc2xpY2UoMCwgMilcbiAgcmV0dXJuIHN0ciA9PT0gJy8vJyB8fCBzdHIgPT09ICcvKidcbn1cblxuZnVuY3Rpb24gaXNSZWdleFN0YXJ0KHN0cikge1xuICByZXR1cm4gc3RyWzBdID09PSAnLycgJiYgIWlzQ29tbWVudFN0YXJ0KHN0clswXSArIHN0clsxXSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZVxuICogQHJldHVybiB7QXJyYXk8W251bWJlciwgc3RyaW5nXT59XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplKGNvZGUpIHtcbiAgbGV0IGN1cnJlbnQgPSAnJ1xuICBsZXQgdHlwZSA9IC0xXG4gIC8qKiBAdHlwZSB7W251bWJlciwgc3RyaW5nXX0gKi9cbiAgbGV0IGxhc3QgPSBbLTEsICcnXVxuICAvKiogQHR5cGUge1tudW1iZXIsIHN0cmluZ119ICovXG4gIGxldCBiZWZvcmVMYXN0ID0gWy0yLCAnJ11cbiAgLyoqIEB0eXBlIHtBcnJheTxbbnVtYmVyLCBzdHJpbmddPn0gKi9cbiAgY29uc3QgdG9rZW5zID0gW11cblxuICAvKiogQHR5cGUgYm9vbGVhbiBpZiBlbnRlcmVkIGpzeCB0YWcsIGluc2lkZSA8b3BlbiB0YWc+IG9yIDwvY2xvc2UgdGFnPiAqL1xuICBsZXQgX19qc3hFbnRlciA9IGZhbHNlXG4gIC8qKlxuICAgKiBAdHlwZSB7MCB8IDEgfCAyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAwIGZvciBub3QgaW4ganN4O1xuICAgKiAxIGZvciBvcGVuIGpzeCB0YWc7XG4gICAqIDIgZm9yIGNsb3NpbmcganN4IHRhZztcbiAgICoqL1xuICBsZXQgX19qc3hUYWcgPSAwXG4gIGxldCBfX2pzeEV4cHIgPSBmYWxzZVxuXG4gIC8vIG9ubHkgbWF0Y2ggcGFpcmVkIChvcGVuICsgY2xvc2UpIHRhZ3MsIG5vdCBzZWxmLWNsb3NpbmcgdGFnc1xuICBsZXQgX19qc3hTdGFjayA9IDBcbiAgY29uc3QgX19qc3hDaGlsZCA9ICgpID0+IF9fanN4RW50ZXIgJiYgIV9fanN4RXhwciAmJiAhX19qc3hUYWdcbiAgLy8gPCBfX2NvbnRlbnRfXyA+XG4gIGNvbnN0IGluSnN4VGFnID0gKCkgPT4gX19qc3hUYWcgJiYgIV9fanN4Q2hpbGQoKVxuICAvLyB7J19fY29udGVudF9fJ31cbiAgY29uc3QgaW5Kc3hMaXRlcmFscyA9ICgpID0+ICFfX2pzeFRhZyAmJiBfX2pzeENoaWxkKCkgJiYgIV9fanN4RXhwciAmJiBfX2pzeFN0YWNrID4gMFxuXG4gIC8qKiBAdHlwZSB7c3RyaW5nIHwgbnVsbH0gKi9cbiAgbGV0IF9fc3RyUXVvdGUgPSBudWxsXG4gIGxldCBfX3N0clRlbXBsYXRlRXhwclN0YWNrID0gMFxuICBsZXQgX19zdHJUZW1wbGF0ZVF1b3RlU3RhY2sgPSAwXG4gIGNvbnN0IGluU3RyaW5nUXVvdGVzID0gKCkgPT4gX19zdHJRdW90ZSAhPT0gbnVsbFxuICBjb25zdCBpblN0clRlbXBsYXRlTGl0ZXJhbHMgPSAoKSA9PiAoX19zdHJUZW1wbGF0ZVF1b3RlU3RhY2sgPiBfX3N0clRlbXBsYXRlRXhwclN0YWNrKVxuICBjb25zdCBpblN0clRlbXBsYXRlRXhwciA9ICgpID0+IF9fc3RyVGVtcGxhdGVRdW90ZVN0YWNrID4gMCAmJiAoX19zdHJUZW1wbGF0ZVF1b3RlU3RhY2sgPT09IF9fc3RyVGVtcGxhdGVFeHByU3RhY2spXG4gIGNvbnN0IGluU3RyaW5nQ29udGVudCA9ICgpID0+IGluU3RyaW5nUXVvdGVzKCkgfHwgaW5TdHJUZW1wbGF0ZUxpdGVyYWxzKClcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBjbGFzc2lmeSh0b2tlbikge1xuICAgIGNvbnN0IGlzTGluZUJyZWFrID0gdG9rZW4gPT09ICdcXG4nXG4gICAgLy8gRmlyc3QgY2hlY2tpbmcgaWYgdGhleSdyZSBhdHRyaWJ1dGVzIHZhbHVlc1xuICAgIGlmIChpbkpzeFRhZygpKSB7XG4gICAgICBpZiAoaW5TdHJpbmdRdW90ZXMoKSkge1xuICAgICAgICByZXR1cm4gVF9TVFJJTkdcbiAgICAgIH1cblxuICAgICAgY29uc3QgWywgbGFzdFRva2VuXSA9IGxhc3RcbiAgICAgIGlmIChpc0lkZW50aWZpZXIodG9rZW4pKSB7XG4gICAgICAgIC8vIGNsYXNzaWZ5IGpzeCBvcGVuIHRhZ1xuICAgICAgICBpZiAoKGxhc3RUb2tlbiA9PT0gJzwnIHx8IGxhc3RUb2tlbiA9PT0gJzwvJykpIFxuICAgICAgICAgIHJldHVybiBUX0VOVElUWVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGVuIGRldGVybWluZSBpZiB0aGV5J3JlIGpzeCBsaXRlcmFsc1xuICAgIGNvbnN0IGlzSnN4TGl0ZXJhbHMgPSBpbkpzeExpdGVyYWxzKClcbiAgICBpZiAoaXNKc3hMaXRlcmFscykgcmV0dXJuIFRfSlNYX0xJVEVSQUxTXG5cbiAgICAvLyBEZXRlcm1pbmUgc3RyaW5ncyBmaXJzdCBiZWZvcmUgb3RoZXIgdHlwZXNcbiAgICBpZiAoaW5TdHJpbmdRdW90ZXMoKSkge1xuICAgICAgcmV0dXJuIFRfU1RSSU5HXG4gICAgfSBlbHNlIGlmIChrZXl3b3Jkcy5oYXModG9rZW4pKSB7XG4gICAgICByZXR1cm4gbGFzdFsxXSA9PT0gJy4nID8gVF9JREVOVElGSUVSIDogVF9LRVlXT1JEXG4gICAgfSBlbHNlIGlmIChpc0xpbmVCcmVhaykge1xuICAgICAgcmV0dXJuIFRfQlJFQUtcbiAgICB9IGVsc2UgaWYgKGlzU3BhY2VzKHRva2VuKSkge1xuICAgICAgcmV0dXJuIFRfU1BBQ0VcbiAgICB9IGVsc2UgaWYgKHRva2VuLnNwbGl0KCcnKS5ldmVyeShpc1NpZ24pKSB7XG4gICAgICByZXR1cm4gVF9TSUdOXG4gICAgfSBlbHNlIGlmIChpc0Nscyh0b2tlbikpIHtcbiAgICAgIHJldHVybiBpbkpzeFRhZygpID8gVF9JREVOVElGSUVSIDogVF9DTFNfTlVNQkVSXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0lkZW50aWZpZXIodG9rZW4pKSB7XG4gICAgICAgIGNvbnN0IGlzTGFzdFByb3BEb3QgPSBsYXN0WzFdID09PSAnLicgJiYgaXNJZGVudGlmaWVyKGJlZm9yZUxhc3RbMV0pXG5cbiAgICAgICAgaWYgKCFpblN0cmluZ0NvbnRlbnQoKSAmJiAhaXNMYXN0UHJvcERvdCkgcmV0dXJuIFRfSURFTlRJRklFUlxuICAgICAgICBpZiAoaXNMYXN0UHJvcERvdCkgcmV0dXJuIFRfUFJPUEVSVFlcbiAgICAgIH1cbiAgICAgIHJldHVybiBUX1NUUklOR1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGFwcGVuZCA9IChfdHlwZSwgX3Rva2VuKSA9PiB7XG4gICAgaWYgKF90b2tlbikge1xuICAgICAgY3VycmVudCA9IF90b2tlblxuICAgIH1cbiAgICBpZiAoY3VycmVudCkge1xuICAgICAgdHlwZSA9IF90eXBlIHx8IGNsYXNzaWZ5KGN1cnJlbnQpXG4gICAgICAvKiogQHR5cGUgW251bWJlciwgc3RyaW5nXSAgKi9cbiAgICAgIGNvbnN0IHBhaXIgPSBbdHlwZSwgY3VycmVudF1cbiAgICAgIGlmICh0eXBlICE9PSBUX1NQQUNFICYmIHR5cGUgIT09IFRfQlJFQUspIHtcbiAgICAgICAgYmVmb3JlTGFzdCA9IGxhc3RcbiAgICAgICAgbGFzdCA9IHBhaXJcbiAgICAgIH1cbiAgICAgIHRva2Vucy5wdXNoKHBhaXIpXG4gICAgfVxuICAgIGN1cnJlbnQgPSAnJ1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGN1cnIgPSBjb2RlW2ldXG4gICAgY29uc3QgcHJldiA9IGNvZGVbaSAtIDFdXG4gICAgY29uc3QgbmV4dCA9IGNvZGVbaSArIDFdXG4gICAgY29uc3QgcF9jID0gcHJldiArIGN1cnIgLy8gcHJldmlvdXMgYW5kIGN1cnJlbnRcbiAgICBjb25zdCBjX24gPSBjdXJyICsgbmV4dCAvLyBjdXJyZW50IGFuZCBuZXh0XG5cbiAgICAvLyBEZXRlcm1pbmUgc3RyaW5nIHF1b3RhdGlvbiBvdXRzaWRlIG9mIGpzeCBsaXRlcmFscy5cbiAgICAvLyBJbnNpZGUganN4IGxpdGVyYWxzLCBzdHJpbmcgcXVvdGF0aW9uIGlzIHN0aWxsIHBhcnQgb2YgaXQuXG4gICAgaWYgKGlzU2luZ2xlUXVvdGVzKGN1cnIpICYmICFpbkpzeExpdGVyYWxzKCkpIHtcbiAgICAgIGFwcGVuZCgpXG4gICAgICBpZiAocHJldiAhPT0gYFxcXFxgKSB7XG4gICAgICAgIGlmIChfX3N0clF1b3RlICYmIGN1cnIgPT09IF9fc3RyUXVvdGUpIHtcbiAgICAgICAgICBfX3N0clF1b3RlID0gbnVsbFxuICAgICAgICB9IGVsc2UgaWYgKCFfX3N0clF1b3RlKSB7XG4gICAgICAgICAgX19zdHJRdW90ZSA9IGN1cnJcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhcHBlbmQoVF9TVFJJTkcsIGN1cnIpXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmICghaW5TdHJUZW1wbGF0ZUxpdGVyYWxzKCkpIHtcbiAgICAgIGlmIChwcmV2ICE9PSAnXFxcXG4nICYmIGlzU3RyVGVtcGxhdGVDaHIoY3VycikpIHtcbiAgICAgICAgYXBwZW5kKClcbiAgICAgICAgYXBwZW5kKFRfU1RSSU5HLCBjdXJyKVxuICAgICAgICBfX3N0clRlbXBsYXRlUXVvdGVTdGFjaysrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluU3RyVGVtcGxhdGVMaXRlcmFscygpKSB7XG4gICAgICBpZiAocHJldiAhPT0gJ1xcXFxuJyAmJiBpc1N0clRlbXBsYXRlQ2hyKGN1cnIpKSB7XG4gICAgICAgIGlmIChfX3N0clRlbXBsYXRlUXVvdGVTdGFjayA+IDApIHtcbiAgICAgICAgICBhcHBlbmQoKVxuICAgICAgICAgIF9fc3RyVGVtcGxhdGVRdW90ZVN0YWNrLS1cbiAgICAgICAgICBhcHBlbmQoVF9TVFJJTkcsIGN1cnIpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY19uID09PSAnJHsnKSB7XG4gICAgICAgIF9fc3RyVGVtcGxhdGVFeHByU3RhY2srK1xuICAgICAgICBhcHBlbmQoVF9TVFJJTkcpXG4gICAgICAgIGFwcGVuZChUX1NJR04sIGNfbilcbiAgICAgICAgaSsrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluU3RyVGVtcGxhdGVFeHByKCkgJiYgY3VyciA9PT0gJ30nKSB7XG4gICAgICBhcHBlbmQoKVxuICAgICAgX19zdHJUZW1wbGF0ZUV4cHJTdGFjay0tXG4gICAgICBhcHBlbmQoVF9TSUdOLCBjdXJyKVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoX19qc3hDaGlsZCgpKSB7XG4gICAgICBpZiAoY3VyciA9PT0gJ3snKSB7XG4gICAgICAgIGFwcGVuZCgpXG4gICAgICAgIGFwcGVuZChUX1NJR04sIGN1cnIpXG4gICAgICAgIF9fanN4RXhwciA9IHRydWVcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX19qc3hFbnRlcikge1xuICAgICAgLy8gPDogb3BlbiB0YWcgc2lnblxuICAgICAgLy8gbmV3ICc8JyBub3QgaW5zaWRlIGpzeFxuICAgICAgaWYgKCFfX2pzeFRhZyAmJiBjdXJyID09PSAnPCcpIHtcbiAgICAgICAgYXBwZW5kKClcbiAgICAgICAgaWYgKG5leHQgPT09ICcvJykge1xuICAgICAgICAgIC8vIGNsb3NlIHRhZ1xuICAgICAgICAgIF9fanN4VGFnID0gMlxuICAgICAgICAgIGN1cnJlbnQgPSBjX25cbiAgICAgICAgICBpKytcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBvcGVuIHRhZ1xuICAgICAgICAgIF9fanN4VGFnID0gMVxuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyXG4gICAgICAgIH1cbiAgICAgICAgYXBwZW5kKFRfU0lHTilcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGlmIChfX2pzeFRhZykge1xuICAgICAgICAvLyA+OiBvcGVuIHRhZyBjbG9zZSBzaWduIG9yIGNsb3NpbmcgdGFnIGNsb3Npbmcgc2lnblxuICAgICAgICAvLyBhbmQgaXQncyBub3QgYD0+YCBvciBgLz5gXG4gICAgICAgIC8vIGBjdXJyYCBjb3VsZCBiZSBgPmAgb3IgYC9gXG4gICAgICAgIGlmICgoY3VyciA9PT0gJz4nICYmICEnLz0nLmluY2x1ZGVzKHByZXYpKSkge1xuICAgICAgICAgIGFwcGVuZCgpXG4gICAgICAgICAgaWYgKF9fanN4VGFnID09PSAxKSB7XG4gICAgICAgICAgICBfX2pzeFRhZyA9IDBcbiAgICAgICAgICAgIF9fanN4U3RhY2srK1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfX2pzeFRhZyA9IDBcbiAgICAgICAgICAgIF9fanN4RW50ZXIgPSBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgICBhcHBlbmQoVF9TSUdOLCBjdXJyKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyA+OiB0YWcgc2VsZiBjbG9zZSBzaWduIG9yIGNsb3NlIHRhZyBzaWduXG4gICAgICAgIGlmIChjX24gPT09ICcvPicgfHwgY19uID09PSAnPC8nKSB7XG4gICAgICAgICAgLy8gaWYgY3VycmVudCB0b2tlbiBpcyBub3QgcGFydCBvZiBjbG9zZSB0YWcgc2lnbiwgcHVzaCBpdCBmaXJzdFxuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSAnPCcgJiYgY3VycmVudCAhPT0gJy8nKSB7XG4gICAgICAgICAgICBhcHBlbmQoKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjX24gPT09ICcvPicpIHtcbiAgICAgICAgICAgIF9fanN4VGFnID0gMFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpcyAnPC8nXG4gICAgICAgICAgICBfX2pzeFN0YWNrLS1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIV9fanN4U3RhY2spXG4gICAgICAgICAgICBfX2pzeEVudGVyID0gZmFsc2VcblxuICAgICAgICAgIGN1cnJlbnQgPSBjX25cbiAgICAgICAgICBpKytcbiAgICAgICAgICBhcHBlbmQoVF9TSUdOKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyA8OiBvcGVuIHRhZyBzaWduXG4gICAgICAgIGlmIChjdXJyID09PSAnPCcpIHtcbiAgICAgICAgICBhcHBlbmQoKVxuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyXG4gICAgICAgICAgYXBwZW5kKFRfU0lHTilcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8ganN4IHByb3BlcnR5XG4gICAgICAgIC8vIGAtYCBpbiBkYXRhLXByb3BcbiAgICAgICAgaWYgKG5leHQgPT09ICctJyAgJiYgIWluU3RyaW5nQ29udGVudCgpICYmICFpbkpzeExpdGVyYWxzKCkpIHtcbiAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgYXBwZW5kKFRfUFJPUEVSVFksIGN1cnJlbnQgKyBjdXJyICsgbmV4dClcbiAgICAgICAgICAgIGkgKz0gMVxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYD1gIGluIHByb3BlcnR5PTx2YWx1ZT5cbiAgICAgICAgaWYgKG5leHQgPT09ICc9Jykge1xuICAgICAgICAgIGNvbnN0IHByb3AgPSBjdXJyZW50ID8gKGN1cnJlbnQgKyBjdXJyKSA6IGN1cnJcbiAgICAgICAgICBpZiAoaXNJZGVudGlmaWVyKHByb3ApKSB7XG4gICAgICAgICAgICBjdXJyZW50ID0gcHJvcFxuICAgICAgICAgICAgYXBwZW5kKFRfUFJPUEVSVFkpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBpdCdzIG5vdCBpbiBhIGpzeCB0YWcgZGVjbGFyYXRpb24gb3IgYSBzdHJpbmcsIGNsb3NlIGNoaWxkIGlmIG5leHQgaXMganN4IGNsb3NlIHRhZ1xuICAgIGlmICghX19qc3hUYWcgJiYgKGN1cnIgPT09ICc8JyAmJiBpc0lkZW50aWZpZXJDaGFyKG5leHQpIHx8IGNfbiA9PT0gJzwvJykpIHtcbiAgICAgIF9fanN4VGFnID0gbmV4dCA9PT0gJy8nID8gMiA6IDFcblxuICAgICAgLy8gY3VycmVudCBhbmQgbmV4dCBjaGFyIGNhbiBmb3JtIGEganN4IG9wZW4gb3IgY2xvc2UgdGFnXG4gICAgICBpZiAoY3VyciA9PT0gJzwnICYmIChuZXh0ID09PSAnLycgfHwgaXNBbHBoYShuZXh0KSkpIHtcbiAgICAgICAgX19qc3hFbnRlciA9IHRydWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBpc1F1b3RhdGlvbkNoYXIgPSBpc1N0cmluZ1F1b3RhdGlvbihjdXJyKVxuICAgIGNvbnN0IGlzU3RyaW5nVGVtcGxhdGVMaXRlcmFscyA9IGluU3RyVGVtcGxhdGVMaXRlcmFscygpXG4gICAgY29uc3QgaXNSZWdleENoYXIgPSAhX19qc3hFbnRlciAmJiBpc1JlZ2V4U3RhcnQoY19uKVxuICAgIGNvbnN0IGlzSnN4TGl0ZXJhbHMgPSBpbkpzeExpdGVyYWxzKClcblxuICAgIC8vIHN0cmluZyBxdW90YXRpb25cbiAgICBpZiAoaXNRdW90YXRpb25DaGFyIHx8IGlzU3RyaW5nVGVtcGxhdGVMaXRlcmFscyB8fCBpc1NpbmdsZVF1b3RlcyhfX3N0clF1b3RlKSkge1xuICAgICAgY3VycmVudCArPSBjdXJyXG4gICAgfSBlbHNlIGlmIChpc1JlZ2V4Q2hhcikge1xuICAgICAgYXBwZW5kKClcbiAgICAgIGNvbnN0IFtsYXN0VHlwZSwgbGFzdFRva2VuXSA9IGxhc3RcbiAgICAgIC8vIFNwZWNpYWwgY2FzZXMgdGhhdCBhcmUgbm90IGNvbnNpZGVyZWQgYXMgcmVnZXg6XG4gICAgICAvLyAqIChleHByMSkgLyBleHByMjogYClgIGJlZm9yZSBgL2Agb3BlcmF0b3IgaXMgc3RpbGwgaW4gZXhwcmVzc2lvblxuICAgICAgLy8gKiA8bm9uIGNvbW1lbnQgc3RhcnQ+LyBleHByOiBub24gY29tbWVudCBzdGFydCBiZWZvcmUgYC9gIGlzIG5vdCByZWdleFxuICAgICAgaWYgKFxuICAgICAgICBpc1JlZ2V4Q2hhciAmJlxuICAgICAgICBsYXN0VHlwZSAhPT0gLTEgJiZcbiAgICAgICAgIShcbiAgICAgICAgICAobGFzdFR5cGUgPT09IFRfU0lHTiAmJiAnKScgIT09IGxhc3RUb2tlbikgfHxcbiAgICAgICAgICBsYXN0VHlwZSA9PT0gVF9DT01NRU5UXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50ID0gY3VyclxuICAgICAgICBhcHBlbmQoKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICBjb25zdCBzdGFydCA9IGkrK1xuXG4gICAgICAvLyBlbmQgb2YgbGluZSBvZiBlbmQgb2YgZmlsZVxuICAgICAgY29uc3QgaXNFb2YgPSAoKSA9PiBpID49IGNvZGUubGVuZ3RoXG4gICAgICBjb25zdCBpc0VvbCA9ICgpID0+IGlzRW9mKCkgfHwgY29kZVtpXSA9PT0gJ1xcbidcblxuICAgICAgbGV0IGZvdW5kQ2xvc2UgPSBmYWxzZVxuICAgICAgLy8gcmVnZXhcbiAgICAgIGZvciAoOyAhaXNFb2woKTsgaSsrKSB7XG4gICAgICAgIGlmIChjb2RlW2ldID09PSAnLycgJiYgY29kZVtpIC0gMV0gIT09ICdcXFxcJykge1xuICAgICAgICAgIGZvdW5kQ2xvc2UgPSB0cnVlXG4gICAgICAgICAgLy8gYXBwZW5kIHJlZ2V4IGZsYWdzXG4gICAgICAgICAgd2hpbGUgKHN0YXJ0ICE9PSBpICYmIC9eW2Etel0kLy50ZXN0KGNvZGVbaSArIDFdKSAmJiAhaXNFb2woKSkge1xuICAgICAgICAgICAgaSsrXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAhPT0gaSAmJiBmb3VuZENsb3NlKSB7XG4gICAgICAgIC8vIElmIGN1cnJlbnQgbGluZSBpcyBmdWxseSBjbG9zZWQgd2l0aCBzdHJpbmcgcXVvdGVzIG9yIHJlZ2V4IHNsYXNoZXMsXG4gICAgICAgIC8vIGFkZCB0aGVtIHRvIHRva2Vuc1xuICAgICAgICBjdXJyZW50ID0gY29kZS5zbGljZShzdGFydCwgaSArIDEpXG4gICAgICAgIGFwcGVuZChUX1NUUklORylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElmIGl0IGRvZXNuJ3QgbWF0Y2ggYW55IG9mIHRoZSBhYm92ZSwganVzdCBsZWF2ZSBpdCBhcyBvcGVyYXRvciBhbmQgbW92ZSBvblxuICAgICAgICBjdXJyZW50ID0gY3VyclxuICAgICAgICBhcHBlbmQoKVxuICAgICAgICBpID0gc3RhcnRcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQ29tbWVudFN0YXJ0KGNfbikpIHtcbiAgICAgIGFwcGVuZCgpXG4gICAgICBjb25zdCBzdGFydCA9IGlcbiAgICAgIGlmIChuZXh0ID09PSAnLycpIHtcbiAgICAgICAgZm9yICg7IGkgPCBjb2RlLmxlbmd0aCAmJiBjb2RlW2ldICE9PSAnXFxuJzsgaSsrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoOyBpIDwgY29kZS5sZW5ndGggJiYgY29kZVtpIC0gMV0gKyBjb2RlW2ldICE9PSAnKi8nOyBpKyspO1xuICAgICAgfVxuICAgICAgY3VycmVudCA9IGNvZGUuc2xpY2Uoc3RhcnQsIGkgKyAxKVxuICAgICAgYXBwZW5kKFRfQ09NTUVOVClcbiAgICB9IGVsc2UgaWYgKGN1cnIgPT09ICcgJyB8fCBjdXJyID09PSAnXFxuJykge1xuICAgICAgaWYgKFxuICAgICAgICBjdXJyID09PSAnICcgJiZcbiAgICAgICAgKFxuICAgICAgICAgIChpc1NwYWNlcyhjdXJyZW50KSB8fCAhY3VycmVudCkgfHxcbiAgICAgICAgICBpc0pzeExpdGVyYWxzXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50ICs9IGN1cnJcbiAgICAgICAgaWYgKG5leHQgPT09ICc8Jykge1xuICAgICAgICAgIGFwcGVuZCgpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFwcGVuZCgpXG4gICAgICAgIGN1cnJlbnQgPSBjdXJyXG4gICAgICAgIGFwcGVuZCgpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChfX2pzeEV4cHIgJiYgY3VyciA9PT0gJ30nKSB7XG4gICAgICAgIGFwcGVuZCgpXG4gICAgICAgIGN1cnJlbnQgPSBjdXJyXG4gICAgICAgIGFwcGVuZCgpXG4gICAgICAgIF9fanN4RXhwciA9IGZhbHNlXG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAvLyBpdCdzIGpzeCBsaXRlcmFscyBhbmQgaXMgbm90IGEganN4IGJyYWNrZXRcbiAgICAgICAgKGlzSnN4TGl0ZXJhbHMgJiYgIWpzeEJyYWNrZXRzLmhhcyhjdXJyKSkgfHxcbiAgICAgICAgLy8gc2FtZSB0eXBlIGNoYXIgYXMgcHJldmlvdXMgb25lIGluIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgKChpc1dvcmQoY3VycikgPT09IGlzV29yZChjdXJyZW50W2N1cnJlbnQubGVuZ3RoIC0gMV0pIHx8IF9fanN4Q2hpbGQoKSkgJiYgIXNpZ25zLmhhcyhjdXJyKSlcbiAgICAgICkge1xuICAgICAgICBjdXJyZW50ICs9IGN1cnJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwX2MgPT09ICc8LycpIHtcbiAgICAgICAgICBjdXJyZW50ID0gcF9jXG4gICAgICAgIH1cbiAgICAgICAgYXBwZW5kKClcblxuICAgICAgICBpZiAocF9jICE9PSAnPC8nKSB7XG4gICAgICAgICAgY3VycmVudCA9IGN1cnJcblxuICAgICAgICB9XG4gICAgICAgIGlmICgoY19uID09PSAnPC8nIHx8IGNfbiA9PT0gJy8+JykpIHtcbiAgICAgICAgICBjdXJyZW50ID0gY19uXG4gICAgICAgICAgYXBwZW5kKClcbiAgICAgICAgICBpKytcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChqc3hCcmFja2V0cy5oYXMoY3VycikpIGFwcGVuZCgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXBwZW5kKClcblxuICByZXR1cm4gdG9rZW5zXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxbbnVtYmVyLCBzdHJpbmddPn0gdG9rZW5zXG4gKiBAcmV0dXJuIHtBcnJheTxzdHJpbmc+fVxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZSh0b2tlbnMpIHtcbiAgY29uc3QgbGluZXNIdG1sID0gW11cbiAgY29uc3QgY3JlYXRlTGluZSA9IChjb250ZW50KSA9PiBgPHNwYW4gY2xhc3M9XCJzaF9fbGluZVwiPiR7Y29udGVudH08L3NwYW4+YFxuXG4gIGZ1bmN0aW9uIGZsdXNoTGluZSh0b2tlbnMpIHtcbiAgICBsaW5lc0h0bWwucHVzaChjcmVhdGVMaW5lKFxuICAgICAgdG9rZW5zLm1hcCgoW3R5cGUsIHZhbHVlXSkgPT4gKFxuICAgICAgICBgPHNwYW4gY2xhc3M9XCJzaF9fdG9rZW4tLSR7dHlwZXNbdHlwZV19XCIgc3R5bGU9XCJjb2xvcjogdmFyKC0tc2gtJHt0eXBlc1t0eXBlXX0pXCI+JHtlbmNvZGUodmFsdWUpfTwvc3Bhbj5gXG4gICAgICApKVxuICAgICAgLmpvaW4oJycpXG4gICAgKSlcbiAgfVxuICBjb25zdCBsaW5lVG9rZW5zID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB0b2tlbiA9IHRva2Vuc1tpXVxuICAgIGNvbnN0IFt0eXBlLCB2YWx1ZV0gPSB0b2tlblxuICAgIGlmICh0eXBlICE9PSBUX0JSRUFLKSB7XG4gICAgICAvLyBEaXZpZGUgbXVsdGktbGluZSB0b2tlbiBpbnRvIG11bHRpLWxpbmUgY29kZVxuICAgICAgaWYgKHZhbHVlLmluY2x1ZGVzKCdcXG4nKSkge1xuICAgICAgICBjb25zdCBsaW5lcyA9IHZhbHVlLnNwbGl0KCdcXG4nKVxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxpbmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgbGluZVRva2Vucy5wdXNoKFt0eXBlLCBsaW5lc1tqXV0pXG4gICAgICAgICAgaWYgKGogPCBsaW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICBmbHVzaExpbmUobGluZVRva2VucylcbiAgICAgICAgICAgIGxpbmVUb2tlbnMubGVuZ3RoID0gMFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGluZVRva2Vucy5wdXNoKHRva2VuKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsaW5lVG9rZW5zLnB1c2goW3R5cGUsICcnXSlcbiAgICAgIGZsdXNoTGluZShsaW5lVG9rZW5zKVxuICAgICAgbGluZVRva2Vucy5sZW5ndGggPSAwXG4gICAgfVxuICB9XG5cbiAgaWYgKGxpbmVUb2tlbnMubGVuZ3RoKVxuICAgIGZsdXNoTGluZShsaW5lVG9rZW5zKVxuXG4gIHJldHVybiBsaW5lc0h0bWxcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGNvZGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodChjb2RlKSB7XG4gIGNvbnN0IHRva2VucyA9IHRva2VuaXplKGNvZGUpXG4gIGNvbnN0IG91dHB1dCA9IGdlbmVyYXRlKHRva2Vucykuam9pbignXFxuJylcbiAgcmV0dXJuIG91dHB1dFxufVxuXG4vLyBuYW1lc3BhY2VcbmNvbnN0IFN1Z2FySGlnaCA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIHtcbiAgVG9rZW5UeXBlczogdHlwZXMsXG59XG5cbmV4cG9ydCB7XG4gIGhpZ2hsaWdodCxcbiAgdG9rZW5pemUsXG4gIFN1Z2FySGlnaCxcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/sugar-high@0.6.0/node_modules/sugar-high/lib/index.js\n");

/***/ })

};
;